---
title: "script_1.1_filter_data"
author: "GKM"
date: "2025-07-15"
output:
  html_document:
    keep_md: TRUE
---

This script is a test script to work with 20250616_benchmark sample to set up a pipeline. It will explore the seurat file, plot and save various plots and determine the QC metrics for both PBMC and T cell sorted populations. 
However, to save the processed seurat object, should run as abatch script, found ~/R/scCHANTS/script_1.11_save_processed_20250616_pbmc_rds.R or ~/R/scCHANTS/script_1.11_save_processed_20250616_pbmc_rds.R

* unzip files
* load into a seurat object
* (in future scirpts will need to do data integration)
* filter and quality control
* normalisation
* (batch effect correction)
* feature selection
* dimensionality reduction
* export Rds file

Before running bear in mind all plots will automatically be saved, I recommend copying plots to your OneDrive folder as you generate them in case of overwriting (though they should be the same!)
Can also search for " ggsave" and replace with "#ggsave" or vice versa

# Load packages
```{r}
library("R.utils")    # need for decompressing files
library("dplyr")
library("Seurat")
library("ggplot2")
library("clustree")
library("patchwork")
```

# Create file path for saving plots
Must create this directory and sub-directories e.g. demultiplex, QC, PCA, others
```{r}
file_path <- "/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/plots"
```


# Decompress the files
```{r}
# only need to do once
# gunzip("/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/20250616_benchmark/matrix.mtx.gz", temporary = TRUE, remove = FALSE)
# gunzip("/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/20250616_benchmark/barcodes.tsv.gz", temporary = TRUE, remove = FALSE)
# gunzip("/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/20250616_benchmark/features.tsv.gz", temporary = TRUE, remove = FALSE)

```

# Load data
```{r}
# load the unzipped files
# gene.column = 2 gives gene symbol/name instead of ENSEMBL ID
scCHANTS_data <- Read10X(data.dir = "/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/20250616_benchmark/", gene.column=2)

# create seurat object
# could add arguments for min.cells or min.features to be included
scCHANTS <- CreateSeuratObject(counts = scCHANTS_data, project = "scCHANTS")

Assays(scCHANTS)
```

## Rename HTO and ADT ids
```{r}
# add HTO and ADT assay to the seurat object as it is by default ignored by CreateSeuratObject
# extract feature names
HTO_names <- rownames(scCHANTS_data$`Antibody Capture`) [1:14]
ADT_names <- rownames(scCHANTS_data$`Antibody Capture`) [15:18]

# extract count matrices
HTO_counts <- scCHANTS_data$`Antibody Capture` [HTO_names, , drop=FALSE]
ADT_counts <- scCHANTS_data$`Antibody Capture` [ADT_names, , drop=FALSE]

# check names and order
rownames(HTO_counts)
rownames(ADT_counts)

# create mapping from long to short names. using - not _ as cannot have underscores in seurat object names
name_to_id <- c(
  "TotalSeq™-C0251 anti-human Hashtag 1 Antibody"  = "HTO-1",
  "TotalSeq™-C0252 anti-human Hashtag 2 Antibody"  = "HTO-2",
  "TotalSeq™-C0253 anti-human Hashtag 3 Antibody"  = "HTO-3",
  "TotalSeq™-C0254 anti-human Hashtag 4 Antibody"  = "HTO-4",
  "TotalSeq™-C0255 anti-human Hashtag 5 Antibody"  = "HTO-5",
  "TotalSeq™-C0256 anti-human Hashtag 6 Antibody"  = "HTO-6",
  "TotalSeq™-C0257 anti-human Hashtag 7 Antibody"  = "HTO-7",
  "TotalSeq™-C0258 anti-human Hashtag 8 Antibody"  = "HTO-8",
  "TotalSeq™-C0259 anti-human Hashtag 9 Antibody"  = "HTO-9",
  "TotalSeq™-C0260 anti-human Hashtag 10 Antibody" = "HTO-10",
  "TotalSeq™-C0296 anti-human Hashtag 11 Antibody" = "HTO-11",
  "TotalSeq™-C0262 anti-human Hashtag 12 Antibody" = "HTO-12",
  "TotalSeq™-C0263 anti-human Hashtag 13 Antibody" = "HTO-13",
  "TotalSeq™-C0264 anti-human Hashtag 14 Antibody" = "HTO-14",
  
  # ADTs
  "TotalSeq-C anti human CD14 (clone M5E2, cat 301859)"             = "ADT-CD14",
  "TotalSeq-C anti human CD16 (clone 3G8 cat 302065)"               = "ADT-CD16",
  "TotalSeq™-C0045 anti-human CD4 Antibody (clone SK3, cat 344651)" = "ADT-CD4",
  "TotalSeq™-C0046 anti-human CD8 Antibody (clone SK1, cat 344753)" = "ADT-CD8"
)

# rename the rows (features) using the mapping
rownames(HTO_counts) <- unname(name_to_id[rownames(HTO_counts)])
rownames(ADT_counts) <- unname(name_to_id[rownames(ADT_counts)])

# check names have changed
rownames(HTO_counts)
rownames(ADT_counts)
```

## Add HTO and ADT assays to seurat object
```{r}
# add HTO assay
scCHANTS[["HTO"]] <- CreateAssayObject(counts = HTO_counts)

# add ADT assay
scCHANTS[["ADT"]] <- CreateAssayObject(counts = ADT_counts)

# validate assays were added
Assays(scCHANTS)

# validate layers
Layers(scCHANTS)
```


```{r}
# check default assay
DefaultAssay(scCHANTS)

# if needed, can change default assay
DefaultAssay(scCHANTS) <- "RNA"

# check number of cells (samples) and features looks right
scCHANTS@assays$RNA
scCHANTS@assays$HTO
scCHANTS@assays$ADT

# free space
rm(scCHANTS_data)
```


# Demulitplex HTOs
For 20250616 data, there is shallow sequencing depth which is resulting in low read cutoffs (2-18, would expect >100), flattened ridgeplots (expect a clear bimodal distribution at 0 and positives not shallow enrichment curves) and (when normalised across cells) low negative calling. Also shown by low peak of total HTO counts per cell histogram
Should check in future experiments whether to normalise across features or cells (use margin argument)

https://satijalab.org/seurat/articles/hashing_vignette

HTODemux:

* Perform a k-medoid clustering on the normalized HTO values, which initially separates cells into K(# of samples)+1 clusters.
* Calculate a ‘negative’ distribution for HTO. For each HTO, the cluster with the lowest average value is used as the negative group.
* For each HTO, fit a negative binomial distribution to the negative cluster. 0.99 quantile of this distribution is used as a threshold.
* Based on these thresholds, each cell is classified as positive or negative for each HTO.
* Cells that are positive for more than one HTOs are annotated as doublets.

```{r}
DefaultAssay(scCHANTS) <- "HTO"

# normalise HTO counts, standard is centered log-ratio (CLR) transformation
# can normalise across features (margin = 1) or across cells (margin = 2)
# comment on github form satija lab that recommend normalising across tags if variation between hash performances but since have very low signals, will try across cells
scCHANTS <- NormalizeData(scCHANTS, assay = "HTO", normalization.method = "CLR", margin = 2)

# using default threshold (quantile of inferred negative distribution for each hashtag), default kfunc is clara (for fast k-medoids clustering on large applications, it is faster and more memory-efficient as it repeatedly samples subsets and clusters those)
scCHANTS <- HTODemux(scCHANTS, assay = "HTO", positive.quantile = 0.99, kfunc = "clara")
```

## Visualise demultiplexing
```{r}
DefaultAssay(scCHANTS) <- "HTO"

# look at classification
table(scCHANTS$HTO_classification.global)

# visualise enrichment for some HTOs, group cells based on the max HTO signal
d1 <- RidgePlot(scCHANTS, assay = "HTO", features = rownames(scCHANTS[["HTO"]])[1:4], ncol = 2, group.by = "HTO_maxID")
d1
# ggsave("HTO_1to4_ridgeplot.png", plot = d1, device = png, height = 25, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )

# look at pairs to see if mutually exclusive
d2 <- FeatureScatter(scCHANTS, feature1 = "HTO-1", feature2 = "HTO-2")
d2
# ggsave("HTO_1vs2_featureplot.png", plot = d2, device = png, height = 10, width = 15, unit = "cm", bg = "white", path = paste0(file_path, "/PBMC_plots/demultiplex/") )

# compare number UMIs
d3 <- VlnPlot(scCHANTS, features = "nCount_RNA", pt.size = 0.1, log = TRUE, group.by = "HTO_classification.global")
d3
# ggsave("HTO_nCount_RNA.png", plot = d3, device = png, height = 10, width = 18, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
```
##commented out
```{r}
# # first remove negative cells from the object
# scCHANTS_nonegs <- subset(scCHANTS, subset = HTO_classification.global != "Negative")
# DefaultAssay(scCHANTS) <- "RNA"
# 
# # should check numbers of cells after subsetting as does not always subset every assay
# length(Cells(scCHANTS))
# length(Cells(scCHANTS_nonegs))
# length(Cells(scCHANTS_nonegs[["RNA"]]))
# length(Cells(scCHANTS_nonegs[["HTO"]]))
# length(Cells(scCHANTS_nonegs[["ADT"]]))
# ## e.g. if counts.Gene Expression and counts.Antibody Capture are removed then RNA layer is no longer subsetted
# 
# # calculate a tSNE embedding of the HTO data
# DefaultAssay(scCHANTS_nonegs) <- "HTO"
# 
# scCHANTS_nonegs <- ScaleData(scCHANTS_nonegs, features = rownames(scCHANTS_nonegs), verbose = TRUE)
# 
# scCHANTS_nonegs <- RunPCA(scCHANTS_nonegs, features = rownames(scCHANTS_nonegs), approx = FALSE)
# 
# scCHANTS_nonegs <- RunUMAP(scCHANTS_nonegs, dims = 1:8, perplexity = 100)
# 
# table(Idents(scCHANTS_nonegs))
# 
# d4 <- DimPlot(scCHANTS_nonegs, group.by = "hash.ID")
# d4
# ggsave("HTO_hashID_umap.png", plot = d4, device = png, height = 10, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
# 
# d5 <- DimPlot(scCHANTS_nonegs, group.by = "HTO_classification.global")
# d5
# ggsave("HTO_classification_umap.png", plot = d5, device = png, height = 10, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )

```
Create a heatmap of HTO signals
```{r}
d6 <- HTOHeatmap(scCHANTS, assay = "HTO", ncells = 5000)
d6
# ggsave("HTO_signal_heatmap.png", plot = d6, device = png, height = 10, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
```

Visualise RNA clustering
This is just mock to check for batch effects. will do clustering etc later on after QC
##commented out
```{r}
# # extract the singlets
# scCHANTS_singlets <- subset(scCHANTS, HTO_classification.global = "Singlet")
# 
# DefaultAssay(scCHANTS_singlets) <- "RNA"
# DefaultLayer(scCHANTS_singlets[["RNA"]])
# # select the top 1000 most variable features
# scCHANTS_singlets <- FindVariableFeatures(scCHANTS_singlets, assay = "RNA", selection.method = "vst", layer = "counts.Gene Expression")
# 
# # normalise and scale RNA data, only scale the variable features here for efficiency
# scCHANTS_singlets <- NormalizeData(scCHANTS_singlets, assay = "RNA", layer = "counts.Gene Expression")
# scCHANTS_singlets <- ScaleData(scCHANTS_singlets, features = VariableFeatures(scCHANTS_singlets))
# 
# # run PCA
# scCHANTS_singlets <- RunPCA(scCHANTS_singlets, features = VariableFeatures(scCHANTS_singlets))
# 
# # select the top 10 PCs for clustering and tSNE based on PCElbowPlot
# scCHANTS_singlets <- FindNeighbors(scCHANTS_singlets, reduction = "pca", dims = 1:10)
# scCHANTS_singlets <- FindClusters(scCHANTS_singlets, resolution = 0.6, verbose = FALSE)
# scCHANTS_singlets <- RunUMAP(scCHANTS_singlets, reduction = "pca", dims = 1:10)
# 
# # project singlet identities on UMAP visualisation
# d7 <- DimPlot(scCHANTS_singlets, group.by = "HTO_classification.global") +
#   labs(title = "RNA UMAP HTO_classification.global")
# d7
# ggsave("HTO_classification_RNA_UMAP.png", plot = d7, device = png, height = 10, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
# 
# # show only a subset
# subset1 <- subset(scCHANTS_singlets, subset = HTO_maxID %in% c("HTO-1", "HTO-2", "HTO-3") )
# d8 <- DimPlot(subset1, group.by = "HTO_maxID") +
#   labs(title = "RNA UMAP HTO_maxID on HTO-1:3")
# d8
# ggsave("HTO_1to3_maxID_RNA_UMAP.png", plot = d8, device = png, height = 10, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
# 
# d9 <- DimPlot(subset1, group.by = "HTO_classification") +
#   labs(title = "RNA UMAP HTO_classification on HTO-1:3") +
#   theme(legend.text=element_text(size=6))
# d9
# ggsave("HTO_1to3_classification_RNA_UMAP.png", plot = d9, device = png, height = 10, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )
# 
# subset2 <- subset(scCHANTS_singlets, subset = HTO_maxID %in% c("HTO-7", "HTO-8", "HTO-9") )
# DimPlot(subset2, group.by = "HTO_classification")

```

## Check HTO data
20250616 data, shallow sequencing has lead to low HTO signal, check the signal here
```{r}
# check HTO counts
HTO_counts <- GetAssayData(scCHANTS, assay = "HTO", layer = "counts")
HTO_counts <- data.frame(HTO_UMIs = Matrix::colSums(HTO_counts))
summary(Matrix::colSums(HTO_counts))
## shows UMI counts are not too low

## checked HTOs are labelled as antibody capture in cell ranger
# check library size
d10 <- ggplot(HTO_counts, aes(x = HTO_UMIs)) +
  geom_histogram(bins = 150, fill = "steelblue", color = "black") +
  labs(main = "Total HTO UMIs per Cell", xlab = "HTO UMIs") 
d10
## not peaking around 0 which is good
# ggsave("HTO_umis_per_cell_histogram.png", plot = d10, device = png, height = 7, width = 12, unit = "cm", path = paste0(file_path, "/PBMC_plots/demultiplex/") )


```





# Reassign scCHANTS to only singlets
```{r}
scCHANTS_full <- scCHANTS
length(Cells(scCHANTS))

scCHANTS <- subset(scCHANTS, subset = HTO_classification.global == "Singlet")

# check cell numbers
length(Cells(scCHANTS))
length(Cells(scCHANTS[["RNA"]]))
length(Cells(scCHANTS[["HTO"]]))
length(Cells(scCHANTS[["ADT"]]))
## not subsetting RNA assay
```

### Remove demultiplexing plots to save memory
```{r}
# remove objects
rm(ADT_counts, HTO_counts, ADT_names, HTO_names, hto_info, name_to_id, subset1, subset2, scCHANTS_nonegs, scCHANTS_singlets)

# remove demultiplexing plots
rm(d1, d2, d3, d4, d5, d6, d7, d8, d9, d10)

```

# Add metadata
```{r}
# examine existing metadata
metadata <- scCHANTS@meta.data

dim(metadata)
head(metadata)
summary(metadata$nCount_RNA)

# read in additional sample metadata
metadata_samples <- read.csv("/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/sample_metadata.csv")

head(metadata_samples)

# steps to add to seurat object

# check HTO values are all singles, no doublets
table(scCHANTS$HTO_classification) 

# align each cell's HTO id to row in the metadata_samples, rownames here represent HTOs but can't have duplicate rownames hence 4.1 etc
hto_info <- metadata_samples[match(scCHANTS$HTO_classification, metadata_samples$HTO), ]
head(hto_info)

# add each row to new variable in metadata
scCHANTS$sample_id <- hto_info$sample
scCHANTS$timepoint <- hto_info$timepoint
scCHANTS$treatment <- hto_info$treatment
scCHANTS$PBMC_or_T <- hto_info$PBMC_or_T

# check new metadata
metadata <- scCHANTS@meta.data

dim(metadata)
colnames(metadata)
metadata[14:17, 14:17]
```

# Separate PBMC and sorted T cell samples
CHeck all assays have same number of cells after
```{r}
print("Full scCHANTS")
DefaultAssay(scCHANTS) <- "RNA"
length(Cells(scCHANTS@assays$RNA))
length(Cells(scCHANTS@assays$HTO))
length(Cells(scCHANTS@assays$ADT))

print("PBMC filtered scCHANTS")
scCHANTS_pbmc <- subset(scCHANTS, subset = PBMC_or_T == "PBMC")
length(Cells(scCHANTS_pbmc@assays$RNA))
length(Cells(scCHANTS_pbmc@assays$HTO))
length(Cells(scCHANTS_pbmc@assays$ADT))

print("T cells filtered scCHANTS")
scCHANTS_t <- subset(scCHANTS, subset = PBMC_or_T == "T")
length(Cells(scCHANTS_t@assays$RNA))
length(Cells(scCHANTS_t@assays$HTO))
length(Cells(scCHANTS_t@assays$ADT))
```

# PBMC pre-processing

## Quality control on PBMCs
```{r}
# calculate mt contamination and add column to metadata
scCHANTS_pbmc[["percent_mt"]] <- PercentageFeatureSet(scCHANTS_pbmc, pattern = "^MT-")

# calculate mt contamination and add column to metadata
scCHANTS_pbmc[["percent_rb"]] <- PercentageFeatureSet(scCHANTS_pbmc, pattern = "^RP[SL]")

# plot on violin plot
qc1 <- VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"), ncol = 2, alpha = 0.3)
## before filtering if mt counts are at 0 check you're in RNA assay as default, check head(rownames(scCHANTS_pbmc)) shows gene names
qc1
# ggsave("QC_violinplots.png", plot = qc1, device = png, height = 18, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )

# feature scatter
ft <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "timepoint") +
  theme(legend.position="none")
mt <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_mt", group.by = "timepoint") + 
  theme(legend.position="none")
rb <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_rb", group.by = "timepoint") +
  theme(legend.position="none")
mt_rb <- FeatureScatter(scCHANTS_pbmc, feature1 = "percent_mt", feature2 = "percent_rb", group.by = "timepoint") +
  theme(legend.position="none")
qc2 <- (ft + mt) / (rb + mt_rb)
qc2
# ggsave("QC_scatterplots.png", plot = qc2, device = png, height = 18, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )

```

## Do subsetting
```{r}
# can subset straightaway based on QC metrics e.g. :
#scCHANTS_pbmc <- subset(scCHANTS_pbmc, subset = nFeature_RNA > 200  & nFeature_RNA < 2500 & percent_mt < 5) 

# or assign new metadata column
# start with all cells labeled as "initial"
scCHANTS_pbmc$QC <- "initial"

# label low nFeature_RNA (< 150)
## i.e. if nFeature_RNA < 150 (and previously passed QC as cautionary step), call it low_nFeature, otherwise leave as initial

scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$nFeature_RNA < 150 & scCHANTS_pbmc$QC == "initial",
  "low_nFeature",
  scCHANTS_pbmc$QC
)

# label high nFeature_RNA (> 2000)
scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$nFeature_RNA > 2000 & scCHANTS_pbmc$QC == "initial",
  "high_nFeature",
  scCHANTS_pbmc$QC
)

# label high mitochondrial content (> 5%)
scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$percent_mt > 5 & scCHANTS_pbmc$QC == "initial",
  "high_mt",
  scCHANTS_pbmc$QC
)

# label combined: low_nFeature + high_mt
scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$nFeature_RNA < 150 & scCHANTS_pbmc$percent_mt > 5 & scCHANTS_pbmc$QC != "pass",
  "low_nFeature_high_mt",
  scCHANTS_pbmc$QC
)

# label combined: high_nFeature + high_mt
scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$nFeature_RNA > 2000 & scCHANTS_pbmc$percent_mt > 5 & scCHANTS_pbmc$QC != "pass",
  "high_nFeature_high_mt",
  scCHANTS_pbmc$QC
)

# finally, label cells that pass all filters
scCHANTS_pbmc$QC <- ifelse(
  scCHANTS_pbmc$nFeature_RNA >= 150 &
    scCHANTS_pbmc$nFeature_RNA <= 2000 &
    scCHANTS_pbmc$percent_mt <= 5 &
    scCHANTS_pbmc$QC == "initial",
  "pass",
  scCHANTS_pbmc$QC
)

```

## Replot QC plots, separated by QC result
```{r}
# look at proportion of QC results
table(scCHANTS_pbmc@meta.data$QC)

pbmc_qc <- table(scCHANTS_pbmc@meta.data$QC) %>%  
  as.data.frame() %>% 
  mutate(percent = Freq / sum(Freq) * 100)

qc3 <- ggplot(pbmc_qc, mapping = aes(x = Var1, y = percent, fill = Var1)) +
  geom_col() +
  theme(axis.text.x = element_text(angle = 30, vjust = 1, hjust=1))
qc3
# ggsave("QC_barplot.png", plot = qc3, device = png, height = 8, width = 15, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )

# plot on violin plot
qc4 <- VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"), ncol = 2, alpha = 0.3, , group.by = "QC")
qc4
# ggsave("QC_violinplots_postQC.png", plot = qc4, device = png, height = 25, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )

# feature scatter, coloured by QC overlaid
ft2 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", split.by = "timepoint", group.by = "QC") +
  theme(legend.position="none")
mt2 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_mt", split.by = "timepoint", group.by = "QC") + 
  theme(legend.position="none")
rb2 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_rb", split.by = "timepoint", group.by = "QC") +
  theme(legend.position="none")
mt_rb2 <- FeatureScatter(scCHANTS_pbmc, feature1 = "percent_mt", feature2 = "percent_rb", split.by = "timepoint", group.by = "QC") +
  theme(legend.position="none")
qc5 <- (ft2 + mt2) / (rb2 + mt_rb2)
qc5
# ggsave("QC_scatterplots_postQC.png", plot = qc5, device = png, height = 22, width = 25, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )

# feature scatter, coloured by QC split
ft3 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", split.by = "QC", group.by = "QC") +
  theme(legend.position="none") +
  theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust=1))
mt3 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_mt", split.by = "QC", group.by = "QC") + 
  theme(legend.position="none") +
  theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust=1))
rb3 <- FeatureScatter(scCHANTS_pbmc, feature1 = "nCount_RNA", feature2 = "percent_rb", split.by = "QC", group.by = "QC") +
  theme(legend.position="none") +
  theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust=1))
mt_rb3 <- FeatureScatter(scCHANTS_pbmc, feature1 = "percent_mt", feature2 = "percent_rb", split.by = "QC", group.by = "QC") +
  theme(legend.position="none") +
  theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust=1))
qc6 <- (ft3 + mt3) / (rb3 + mt_rb3)
qc6
# ggsave("QC_scatterplots_postQC_split.png", plot = qc6, device = png, height = 18, width = 35, unit = "cm", path = paste0(file_path, "/PBMC_plots/QC/") )
```

Subset QCd PBMCs
```{r}
scCHANTS_pbmc <- subset(scCHANTS_pbmc, subset = QC == "pass")
length(Cells(scCHANTS_pbmc@assays$RNA))
length(Cells(scCHANTS_pbmc@assays$HTO))
length(Cells(scCHANTS_pbmc@assays$ADT))
```

## Remove QC plots to save memory
```{r}
rm(ft, ft2, ft3, mt, mt2, mt3, mt_rb, mt_rb2, mt_rb3, pbmc_qc, qc1, qc2, qc3, qc4, qc5, qc6, rb, rb2, rb3) 
```


## Normalisation of PBMCs
Default is lognormalise, a global-scaling normalisation method normalises feature expression measurements for each cell by total expression, x by 10,000 by default and log-transforms the result. It stores these in [["RNA"]]$data
Assumes each cell originally contains same number of RNA molecules
Can also use SCTransform (also replaces FindVariableFeatures and ScaleData)
```{r}
DefaultAssay(scCHANTS_pbmc) <- "RNA"
DefaultLayer(scCHANTS_pbmc[["RNA"]])

# normalise
scCHANTS_pbmc <- NormalizeData(scCHANTS_pbmc, normalization.method = "LogNormalize", scale.factor = 10000)

# find variable features
scCHANTS_pbmc <- FindVariableFeatures(scCHANTS_pbmc, selection.method = "vst", nfeatures = 2000, layer = "counts.Gene Expression")

# identify 10 most highly variable genes
top10_features <- head(VariableFeatures(scCHANTS_pbmc), 10)

# to plot these 10 most variable genes
pca1 <- VariableFeaturePlot(scCHANTS_pbmc) %>% LabelPoints(points = top10_features, repel = TRUE) +
  labs(title = "PBMC Variable features")
pca1
## NAs introduced are all for HTO or ADT rows
hvf_info <- HVFInfo(scCHANTS_pbmc)
summary(is.na(hvf_info))
hvf_info[!complete.cases(hvf_info), ]
# ggsave("PCA_variablefeatures_labelled.png", plot = pca1, device = png, bg = "white", height = 14, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

# scale data
all.genes <- rownames(scCHANTS_pbmc)
scCHANTS_pbmc <- ScaleData(scCHANTS_pbmc, features = all.genes)
```

## Dim red on PBMC
```{r}
# run PCA
scCHANTS_pbmc <- RunPCA(scCHANTS_pbmc, features = VariableFeatures(object = scCHANTS_pbmc))

# visualise
pca2 <- VizDimLoadings(scCHANTS_pbmc, dims = 1:2, reduction = "pca")
pca2
# ggsave("PCA_top_pc1to2_genes.png", plot = pca2, device = png, height = 14, width = 18, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

# to save a heatmap must 'capture it' with png
# while (dev.cur() > 1) dev.off()
# png(paste0(file_path, "/PBMC_plots/PCA/PCA_pc1_heatmap.png"), width = 7, height = 6, units = "in", res = 300 )
DimHeatmap(scCHANTS_pbmc, dims = 1, cells = 500, balanced = TRUE)
dev.off() # closes png device

# png(paste0(file_path, "/PBMC_plots/PCA/PCA_pc1to15_heatmap.png"), width = 7, height = 16, units = "in", res = 300 )
DimHeatmap(scCHANTS_pbmc, dims = 1:15, cells = 500, balanced = TRUE)
dev.off() # closes png device

# determine pc number to use
# generate elbow plot and save as a variable
pca3 <- ElbowPlot(scCHANTS_pbmc) +
  labs(title = "PBMC elbow plot")
pca3
# ggsave("PCA_elbowplot.png", plot = pca3, device = png, height = 7, width = 9, unit = "cm", bg = "white", path = paste0(file_path, "/PBMC_plots/PCA/") )

# if not clear then do this calculation to find where drop in variance explained between two successive PCs no longer significant (is <0.1%)
pct <- scCHANTS_pbmc[["pca"]]@stdev / sum(scCHANTS_pbmc[["pca"]]@stdev) * 100
# calculate cumulative percents for each PC
cumu <- cumsum(pct)
# determine the difference between variation of PC and subsequent PC
# give the last point where difference in % of variation is more than 0.1%
sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
## 9

```

## Deciding resolution for clustering
```{r}
scCHANTS_pbmc <- FindNeighbors(scCHANTS_pbmc, dims = 1:9) 

scCHANTS_pbmc <- FindClusters(scCHANTS_pbmc, resolution = c(0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 1))
# this creates multiple clustering columns named e.g. RNA_snn_res.0.2
colnames(scCHANTS_pbmc@meta.data)

pca4 <- clustree(scCHANTS_pbmc, prefix = "RNA_snn_res.", layout = "sugiyama") # sugiyama layout minimises number of crossing edges, can be easier to read
pca4
# ggsave("PCA_compare_res_clusteringtree.png", plot = pca4, device = png, height = 22, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )
## decided on 0.7, this is where the branches are relatively stable

# set resolution as default
Idents(scCHANTS_pbmc) <- "RNA_snn_res.0.7"
```

Plot clustree based on gene exp etc
```{r}
# use median to see typical expression per cluster, avoid misleading high expressing cells
# mean if interested in total contribution of a gene and know expression isn't skewed
# however, all nodes are same colour across clusters if use median, use mean initially

markers <- c("CD3D", "CD3E", "CD8A", "CD8B", "NKG7", "CD14", "CD79A", "CD1C", "PF4")

rm(gene_trees)
gene_trees <- lapply(markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca5 <- wrap_plots(gene_trees, ncol = 3)
pca5
# ggsave("PCA_mean_gene_exp_clusteringtree.png", plot = pca5, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

gene_trees2 <- lapply(markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "median",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca6 <- wrap_plots(gene_trees2, ncol = 3)
pca6
# ggsave("PCA_median_gene_exp_clusteringtree.png", plot = pca6, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

# extract and save legend for plasma colour scale
with_legend <- clustree(scCHANTS_pbmc,
                       prefix = "RNA_snn_res.", 
                       node_colour = "CD8B", 
                       layout = "sugiyama", 
                       node_colour_aggr = "mean",
                       node_colour_layer = "counts.Gene Expression") +
  scale_colour_viridis(option = "plasma")
with_legend

# ggsave("PCA_gene_exp_clusteringtree_legend.png", plot = with_legend, device = png, height = 25, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

```

Specific cell type marker genes - using Oelen et al marker genes
```{r}
# CD4 T cells
# all high bar last two, CCR7 and SELL in naive, LTB, IL7R AND S100A4 in memory
CD4_markers <- c("CD3D", "CD3E", "CD3G", "CCR7", "SELL", "LTB", "IL7R", "CD8A", "CD8B")

CD4_trees <- lapply(CD4_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca7 <- wrap_plots(CD4_trees, ncol = 3)
pca7
# ggsave("PCA_mean_CD4_gene_exp_clusteringtree.png", plot = pca7, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# CD8 T cells
# all high, CCR7 and SELL in naive, LTB, IL7R AND S100A4 in memory
CD8_markers <- c("CD8A", "CD8B", "CD3D", "CD3E", "CD3G", "GZMB", "PRF1", "CCR7", "SELL", "LTB", "IL7R", "S100A4")

CD8_trees <- lapply(CD8_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca8 <- wrap_plots(CD8_trees, ncol = 3)
pca8
# ggsave("PCA_mean_CD8_gene_exp_clusteringtree.png", plot = pca8, device = png, height = 55, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# Monocytes
# CD14 high, LYZ, S100A9 and CSF3R high in classical, low in non-classical, FCGR3A, LYN, CSF1R and IFITM1-3 high in non-classical, low in classical
mono_markers <- c("CD14", "LYZ", "S100A9", "CSF3R", "FCGR3A", "LYN", "CSF1R", "IFITM1", "IFITM2")

mono_trees <- lapply(mono_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca9 <- wrap_plots(mono_trees, ncol = 3)
pca9
# ggsave("PCA_mean_mono_gene_exp_clusteringtree.png", plot = pca9, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# NK
# NKG7 nad GNLY high in dim and bright, CD8A/B low, FCGR3A, GZMB and PRF1 high in dim but low in bright, KLRC1 high in bright
NK_markers <- c("NKG7", "GNLY", "FCGR3A", "GZMB", "PRF1", "KLRC1", "CD8A", "CD8B")

NK_trees <- lapply(NK_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca10 <- wrap_plots(NK_trees, ncol = 3)
pca10
# ggsave("PCA_mean_NK_gene_exp_clusteringtree.png", plot = pca10, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# B
# all high, no MS4A1 in plasma
B_markers <- c("CD79A", "MS4A1")

B_trees <- lapply(B_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca11 <- wrap_plots(B_trees, ncol = 2)
pca11
# ggsave("PCA_mean_B_gene_exp_clusteringtree.png", plot = pca11, device = png, height = 14, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# DC
# CD1C and ITGAX high in myeloid, CLEC4C low, CLEC4C high in plasmacytoid, CD1C, ITGAX low, CD14 low in both
DC_markers <- c("CD1C", "ITGAX", "CLEC4C", "CD14")

DC_trees <- lapply(DC_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca12 <- wrap_plots(DC_trees, ncol = 2)
pca12
# ggsave("PCA_mean_DC_gene_exp_clusteringtree.png", plot = pca12, device = png, height = 30, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


# megakaryotcytes
# all high
megak_markers <- c("GP9", "ITGA2B", "PF4", "PPBP")

megak_trees <- lapply(megak_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "RNA_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "counts.Gene Expression") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca13 <- wrap_plots(megak_trees, ncol = 2)
pca13
# ggsave("PCA_mean_megak_gene_exp_clusteringtree.png", plot = pca13, device = png, height = 30, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )


```

## Run umap and visualise
```{r}
scCHANTS_pbmc <- RunUMAP(scCHANTS_pbmc, dims = 1:9)

# create an empty list to hold the plots
umap_plots <- list()

# loop through each resolution
for (res in c("0.2", "0.4", "0.5", "0.6", "0.7", "0.8", "1")) {
  res_col <- paste0("RNA_snn_res.", res)
  Idents(scCHANTS_pbmc) <- res_col
  
  p <- DimPlot(scCHANTS_pbmc, reduction = "umap", label = TRUE) +
       ggtitle(paste("Resolution", res))
  
  umap_plots[[as.character(res)]] <- p
}

#combine plots into a grid layout
pca14 <- wrap_plots(umap_plots, ncol = 3)
pca14
# ggsave("PCA_compare_res_umaps.png", plot = pca14, device = png, height = 25, width =30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )


# plot RNA counts, mt and rb contamination
pca15 <- VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"), ncol = 2, alpha = 0.3, group.by = "RNA_snn_res.0.7")
pca15
# ggsave("PCA_compare_clusters_violinplots.png", plot = pca15, device = png, height = 22, width = 25, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

# plot cluster sizes, must extract first
cluster_counts <- table(Idents(scCHANTS_pbmc)) %>% 
  as.data.frame() %>% 
  mutate(Var1 = as.factor(Var1)) # so can colour based on it
colnames(cluster_counts) <- c("cluster", "cell_count")

head(cluster_counts)

pca16 <- ggplot(cluster_counts, aes(x = cluster, y = cell_count, fill = cluster)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Cluster Sizes", x = "Cluster", y = "Number of Cells") +
  theme(legend.position = "none")
pca16
# ggsave("PCA_compare_cluster_size_barplots.png", plot = pca16, device = png, height = 10, width = 10, unit = "cm", bg = "white", path = paste0(file_path, "/PBMC_plots/PCA/") )


```



## Remove PCA plots and clustering resolution columns
```{r}
scCHANTS_pbmc@meta.data <- scCHANTS_pbmc@meta.data[, !grepl("RNA_snn_res", colnames(scCHANTS_pbmc@meta.data))]

# recluster with determined resolution
scCHANTS_pbmc <- FindClusters(scCHANTS_pbmc, resolution = 0.7)
colnames(scCHANTS_pbmc@meta.data)
Idents(scCHANTS_pbmc) <- "RNA_snn_res.0.7"

rm(hvf_info, p, pca1, pca2, pca3, pca4, pca5, pca6, pca7)
```



```{r}
# plot umap coloured by cell_type and cell_type_lowerres
pca6 <- DimPlot(scCHANTS_pbmc, reduction = "umap", group.by = "sample_id")
pca6
# ggsave("PCA_sample_id_umap.png", plot = pca6, device = png, height = 10, width =10, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

pca7 <- DimPlot(scCHANTS_pbmc, reduction = "umap", group.by = "timepoint")
pca7
# ggsave("PCA_timepoint_umap.png", plot = pca7, device = png, height = 10, width =10, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

```

# Find markers for clusters
I recommend running find markers and saveRDS as a batch script, see ~/R/scCHANTS/script_1.11_save_processed_20250616_pbmc_rds.R
```{r}
# must join layers to do find markers
scCHANTS_pbmc <- JoinLayers(scCHANTS_pbmc)

# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc_markers <- FindAllMarkers(scCHANTS_pbmc, only.pos = TRUE)
pbmc_markers %>%
    group_by(RNA_snn_res.0.7) %>%
    dplyr::filter(avg_log2FC > 1)

# write.csv(pbmc_markers,"/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/scCHANTS_pbmc_markers.Rds")
```



# save PBMC pre-processed RDS (takes a long time)
I recommend running find markers and saveRDS as a batch script, see ~/R/scCHANTS/script_1.11_save_processed_20250616_pbmc_rds.R
```{r}
# saveRDS(object=scCHANTS_pbmc, file ="/cephfs/volumes/hpc_data_prj/id_hill_sims_wellcda/c1947608-5b3a-4d60-8179-b8e0779d7319/scratch_tmp/scCHANTS/20250616_benchmark/20250616_scCHANTS_pbmc_processed.Rds")

```


# T cell pre-processing
## Quality control on T cells

