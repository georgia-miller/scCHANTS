---
title: "script_2.2a_merge_process_pbmc_20250805"
author: "GKM"
date: "2025-08-11"
output:
  html_document:
    keep_md: TRUE
---

Functionalise the processes done in script 2.1:

• load data
• HTO demultiplex
• add metadata
• split PBMCs and T cells
• QC on PBMCs

```{r}
library("dplyr")
library("tidyr")
library("Seurat")
library("ggplot2")
library("sctransform")
library("patchwork")
library("clustree")
library("viridis")


# before doing sctransform for first time, allows faster running
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# BiocManager::install("glmGamPoi")

# install.packages("sctransform")
```


```{r}
file_path <- "/scratch/prj/id_hill_sims_wellcda/scCHANTS/20250805_run1/plots"
#file_path <- "/Users/k2477939/Library/CloudStorage/OneDrive-King\'sCollegeLondon/General\ -\ Laboratory\ of\ Molecular\ Immunotherapy\ and\ Antibiotics/Data/Georgia\ Miller/scCHANTS/20250805_run1/plots/"
```

Plot cell numbers for each donor at each stage of processing, manually input cell numbers
```{r}
df <- tibble(donor = c(55, 55, 60, 60, 90, 90, 96, 96),
             cells = c("PBMC", "T", "PBMC", "T", "PBMC", "T", "PBMC", "T"),
             pre_demux = c(17837, 17837, 15771, 15771, 6659, 6659, 15179, 15179),
             post_demux = c(15206, 15206, 12818, 12818, 4240, 4240, 12759, 12759),
             pre_qc = c(8103, 8218, 7742, 6208, 2276, 1800, 6761, 6828),
             post_qc = c(7826, 7978, 7506, 6042, 2647, 1737, 6566, 6722)
             ) %>% 
  pivot_longer(cols = 3:6) %>% 
  mutate(donor = as.factor(donor),
         cells = as.factor(cells),
         name = factor(name, 
                       levels = c("pre_demux", "post_demux", "pre_qc", "post_qc")) )

plot <- ggplot(df, mapping = aes(x = name, y = value, colour = donor, group = donor)) + 
  geom_point() + 
  geom_line() + 
  facet_wrap(vars(cells)) +
  labs(x = "Processing stage", y = "Cell count", colour = "Donor")
plot

#ggsave("cell_counts.png", plot = plot, device = png, height = 10, width = 20, unit = "cm", path = file_path)


# plot instead per donor where the first two processing stages are collated
df2 <- df %>% 
  # overwrite cell type for the first two stages
  mutate(cells_plot = ifelse(name %in% c("pre_demux", "post_demux"), "Total", as.character(cells))
         ) %>% 
  distinct(donor, name, cells_plot, .keep_all = TRUE)

plot2 <- ggplot(df2, aes(x = name, y = value, fill = cells_plot)) +
  geom_col(position = "stack") +
  facet_wrap(vars(donor)) +
  theme_minimal() +
  labs(x = "Processing stage", y = "Cell count", fill = "Cell type")
plot2

#ggsave("cell_counts_stacked.png", plot = plot2, device = png, bg = "white", height = 15, width = 20, unit = "cm", path = file_path)

# rm(df, df2, plot, plot2)
```


```{r}
demux_qc <- function(date, run, donor, pbmc_or_t = c("pbmc", "t"), remote = "no", clr_norm = 2, demux_positive = 0.99, nFeature_min, nFeature_max, mt_max) {
  
  # check all args are valid
  stopifnot(
  remote %in% c("yes", "no"),
  pbmc_or_t %in% c("pbmc", "t"),
  clr_norm %in% c(1, 2),
  demux_positive >= 0 & demux_positive <= 0.99,
  is.numeric(nFeature_min), length(nFeature_min) == 1,
  is.numeric(nFeature_max), length(nFeature_max) == 1,
  is.numeric(mt_max), length(mt_max) == 1,
  # check donor has 3 digits
  grepl("^[0-9]{3}$", donor)
  )
  
  ## Load data
  # create local or remote file path
  date_run <- paste0(date, "_run", run)
  file_path <- if(remote == "no") {
    "/Users/k2477939/Library/CloudStorage/OneDrive-King\'sCollegeLondon/General\ -\ Laboratory\ of\ Molecular\ Immunotherapy\ and\ Antibiotics/Data/Georgia\ Miller/scCHANTS/"
  } else if(remote == "yes") {
    "/scratch/prj/id_hill_sims_wellcda/scCHANTS/"
  }
  data_path <- paste0(file_path, date_run, "/", date_run, "_", donor)
    
  # load 10x file
  scCHANTS_data <- Read10X(data.dir = data_path, gene.column=2)
  
  # create seurat object
  scCHANTS <- CreateSeuratObject(counts = scCHANTS_data, project = "scCHANTS")

  
  ## Rename HTO and ADT IDs
  # extract feature names
  HTO_names <- rownames(scCHANTS_data$`Antibody Capture`) [1:13]
  ADT_names <- rownames(scCHANTS_data$`Antibody Capture`) [14:17]

  # extract count matrices
  HTO_counts <- scCHANTS_data$`Antibody Capture` [HTO_names, , drop=FALSE]
  ADT_counts <- scCHANTS_data$`Antibody Capture` [ADT_names, , drop=FALSE]

  # to check names and order
  # message("New HTO names are:")
  # print(rownames(HTO_counts))
  # message("New ADT names are:")
  # print(rownames(ADT_counts))

  # create mapping from long to short names
  name_to_id <- c(
    "TotalSeq™-C0251 anti-human Hashtag 1 Antibody"  = "HTO-1",
    "TotalSeq™-C0252 anti-human Hashtag 2 Antibody"  = "HTO-2",
    "TotalSeq™-C0253 anti-human Hashtag 3 Antibody"  = "HTO-3",
    "TotalSeq™-C0254 anti-human Hashtag 4 Antibody"  = "HTO-4",
    "TotalSeq™-C0255 anti-human Hashtag 5 Antibody"  = "HTO-5",
    "TotalSeq™-C0256 anti-human Hashtag 6 Antibody"  = "HTO-6",
    "TotalSeq™-C0257 anti-human Hashtag 7 Antibody"  = "HTO-7",
    "TotalSeq™-C0258 anti-human Hashtag 8 Antibody"  = "HTO-8",
    "TotalSeq™-C0259 anti-human Hashtag 9 Antibody"  = "HTO-9",
    "TotalSeq™-C0260 anti-human Hashtag 10 Antibody" = "HTO-10",
    "TotalSeq™-C0296 anti-human Hashtag 11 Antibody" = "HTO-11",
    "TotalSeq™-C0262 anti-human Hashtag 12 Antibody" = "HTO-12",
    "TotalSeq™-C0263 anti-human Hashtag 13 Antibody" = "HTO-13",
  
    # ADTs
    "TotalSeq-C anti human CD14 (clone M5E2, cat 301859)"             = "ADT-CD14",
    "TotalSeq-C anti human CD16 (clone 3G8 cat 302065)"               = "ADT-CD16",
    "TotalSeq™-C0045 anti-human CD4 Antibody (clone SK3, cat 344651)" = "ADT-CD4",
    "TotalSeq™-C0046 anti-human CD8 Antibody (clone SK1, cat 344753)" = "ADT-CD8"
    )

  # rename the rows (features) using the mapping
  rownames(HTO_counts) <- unname(name_to_id[rownames(HTO_counts)])
  rownames(ADT_counts) <- unname(name_to_id[rownames(ADT_counts)])

  # check names have changed
  message("New HTO names are:")
  print(rownames(HTO_counts))
  message("New ADT names are:")
  print(rownames(ADT_counts))


  ## Add HTO and ADT assays to seurat object
  # add HTO assay
  scCHANTS[["HTO"]] <- CreateAssayObject(counts = HTO_counts)

  # add ADT assay
  scCHANTS[["ADT"]] <- CreateAssayObject(counts = ADT_counts)

  # validate assays and layers were added
  message("Assays are:")
  print(Assays(scCHANTS))

  # check number of cells (samples) and features looks right
  message("Features and cell numbers for RNA assay:")
  print(scCHANTS@assays$RNA)
  message("Features and cell numbers for HTO assay:")
  print(scCHANTS@assays$HTO)
    message("Features and cell numbers for ADT assay:")
  print(scCHANTS@assays$ADT)


  ## Demultiplex HTOs
  # remove empty cells, add total RNA and HTO counts to metadata then filter using them
  scCHANTS$totRNA <- Matrix::colSums(scCHANTS@assays$RNA@layers$`counts.Gene Expression`)
  scCHANTS$totHTO <- Matrix::colSums(scCHANTS@assays$HTO@counts)

  scCHANTS <- subset(scCHANTS, subset = totRNA > 0 | totHTO > 0)

  DefaultAssay(scCHANTS) <- "HTO"

  # normalise HTO counts, standard is centered log-ratio (CLR) transformation
  # can normalise across features (margin = 1) or across cells (margin = 2)
  # comment on github forum satija lab says they recommend normalising across tags if variation between hash performances but since have very low signals, will try across cells
  scCHANTS <- NormalizeData(scCHANTS, assay = "HTO", normalization.method = "CLR", margin = clr_norm)

  scCHANTS <- HTODemux(scCHANTS, assay = "HTO", positive.quantile = demux_positive, kfunc = "clara")

  DefaultAssay(scCHANTS) <- "HTO"
  
  message("Original number of cells:")
  print(length(Cells(scCHANTS)))

  scCHANTS <- subset(scCHANTS, subset = HTO_classification.global == "Singlet")

  message("Number of cells after subsetting for singlets in RNA, HTO and ADT assays (should all be the same):")
  print(length(Cells(scCHANTS[["RNA"]])))
  print(length(Cells(scCHANTS[["HTO"]])))
  print(length(Cells(scCHANTS[["ADT"]])))

  
  ## Add metadata
  # read in additional sample metadata
  metadata_samples <- read.csv(paste0(file_path, "sample_metadata.csv"))

  # align each cell's HTO id to row in the metadata_samples
  # rownames here represent HTOs but can't have duplicate rownames hence e.g. 4.1
  hto_info <- metadata_samples[match(scCHANTS$HTO_classification, metadata_samples$HTO), ]
  head(hto_info)

  # add each row to a new variable in metadata
  scCHANTS$sample_id <- hto_info$sample
  scCHANTS$timepoint <- hto_info$timepoint
  scCHANTS$treatment <- hto_info$treatment
  scCHANTS$PBMC_or_T <- hto_info$PBMC_or_T

  # here also reorder HTO levels (get all unique levels, order numerically and factorise HTO_classification metadata column)
  hto_levels <- unique(scCHANTS$HTO_classification)
  hto_levels <- hto_levels[order(as.numeric(sub("HTO-", "", hto_levels)))]
  scCHANTS$HTO_classification <- factor(
    scCHANTS$HTO_classification,
    levels = hto_levels
    )

  # print number of cells per sample
  message("Number of cells per sample:")
  print(table(scCHANTS$HTO_classification))

  # order timepoints
  timepoint_levels <- c("0", "7", "28", "benchmark")
  scCHANTS$timepoint <- factor(
    scCHANTS$timepoint,
    levels = timepoint_levels
  )

  ## Split into PBMCs and T cells
  DefaultAssay(scCHANTS) <- "RNA"
  message("Cell number before splitting:")
  print(length(Cells(scCHANTS@assays$RNA)))
  
  message("PBMC cell number in each assay incl benchmark sample 13:")
  scCHANTS_pbmc <- subset(scCHANTS, subset = PBMC_or_T == "PBMC")
  print(length(Cells(scCHANTS_pbmc@assays$RNA)))
  print(length(Cells(scCHANTS_pbmc@assays$HTO)))
  print(length(Cells(scCHANTS_pbmc@assays$ADT)))

  message("T cell number in each assay incl benchmark sample 13:")
  scCHANTS_t <- subset(scCHANTS, subset = PBMC_or_T == "T" | sample_id == "13")
  print(length(Cells(scCHANTS_t@assays$RNA)))
  print(length(Cells(scCHANTS_t@assays$HTO)))
  print(length(Cells(scCHANTS_t@assays$ADT)))
  
  
  ## Rename scCHANTS to designated pbmc or t cell subset
  if(pbmc_or_t == "pbmc") {
    scCHANTS <- scCHANTS_pbmc
    pbmc_or_t_up <- "PBMCs"
  } else if (pbmc_or_t == "t") {
    scCHANTS <- scCHANTS_t
    pbmc_or_t_up <- "T cells"
  }
  
  message(paste0("Subsetted to ", pbmc_or_t_up, " only"))
  
  
  ## Quality control
  # calculate mt contamination and add column to metadata
  scCHANTS[["percent_mt"]] <- PercentageFeatureSet(scCHANTS, pattern = "^MT-")

  # calculate mt contamination and add column to metadata
  scCHANTS[["percent_rb"]] <- PercentageFeatureSet(scCHANTS, pattern = "^RP[SL]")

  scCHANTS <- subset(scCHANTS, subset = nFeature_RNA >= nFeature_min  & nFeature_RNA <= nFeature_max & percent_mt <= mt_max) 

  message(paste0("Number of cells in each assay post-QC using metrics:   ", nFeature_min, " <= nFeature_RNA <= ", nFeature_max, "    and percent_mt   <= ", mt_max))
  print(length(Cells(scCHANTS@assays$RNA)))
  print(length(Cells(scCHANTS@assays$HTO)))
  print(length(Cells(scCHANTS@assays$ADT)))
  
  message("Donor, data and run number added to metadata")
  
  scCHANTS$date <- date
  scCHANTS$run <- run
  scCHANTS$donor <- donor
  
  # remove counts.Antibody Capture layer from RNA assay
  scCHANTS[["RNA"]] <- CreateAssayObject(counts = scCHANTS@assays$RNA$`counts.Gene Expression`)
  message("counts.Antibody Capture removed from RNA assay. RNA assay is now:")
  print(scCHANTS@assays$RNA)
  
  message("...........................................................................................................................................................")
  message(paste0("HTO demux and Quality Control completed for ", pbmc_or_t_up, " for donor ", donor, " in run ", run, " sequenced on ", date))
 
  # return the processed object
  return(scCHANTS)

  }

```

Variables to test the function bit by bit
```{r}
# date = "20250805"
# run = "1"
# donor = "090"
# pbmc_or_t = "pbmc"
# remote = "no"
# clr_norm = 2
# demux_positive = 0.99
# nFeature_min = 1100
# nFeature_max = 4000
# mt_max = 7
```

```{r}
scCHANTS_055_pbmc <- demux_qc(date = "20250805", run = "1", donor = "055", pbmc_or_t = "pbmc", remote = "yes", clr_norm = 2, demux_positive = 0.99, nFeature_min = 1100, nFeature_max = 4000, mt_max = 7)

scCHANTS_060_pbmc <- demux_qc(date = "20250805", run = "1", donor = "060", pbmc_or_t = "pbmc", remote = "yes", clr_norm = 2, demux_positive = 0.99, nFeature_min = 1100, nFeature_max = 4000, mt_max = 7)

# for donor 90, demux_positive is 0.95 and nFeature_min is 1000 unlike for other donors
scCHANTS_090_pbmc <- demux_qc(date = "20250805", run = "1", donor = "090", pbmc_or_t = "pbmc", remote = "yes", clr_norm = 2, demux_positive = 0.95, nFeature_min = 1000, nFeature_max = 4000, mt_max = 7)

scCHANTS_096_pbmc <- demux_qc(date = "20250805", run = "1", donor = "096", pbmc_or_t = "pbmc", remote = "yes", clr_norm = 2, demux_positive = 0.99, nFeature_min = 1100, nFeature_max = 4000, mt_max = 7)
```

## Merge the donors
```{r}
# merge the four seurat objects, add suffix to cell names
scCHANTS_pbmc <- merge(scCHANTS_055_pbmc, c(scCHANTS_060_pbmc, scCHANTS_090_pbmc, scCHANTS_096_pbmc), add.cell.ids = c("D055", "D060", "D090", "D096"))

# check number of cells is correct
n055 <- Cells(scCHANTS_055_pbmc) %>%  length()
n060 <- Cells(scCHANTS_060_pbmc) %>%  length()
n090 <- Cells(scCHANTS_090_pbmc) %>%  length()
n096 <- Cells(scCHANTS_096_pbmc) %>%  length()
Cells(scCHANTS_pbmc) %>%  length()
n055 + n060 + n090 + n096

# check donor data has merged, not kept as separate layer
Layers(scCHANTS_pbmc@assays$RNA)

# change default assay to RNA
DefaultAssay(scCHANTS_pbmc) <- "RNA"

```

When ensured is fully merged etc, remove to save memory
```{r remove objects}
rm(scCHANTS_055_pbmc, scCHANTS_060_pbmc, scCHANTS_090_pbmc, scCHANTS_096_pbmc)
```


## Normalisation and dimensional reduction
If there are global differences between gorups, may have to split and normalise separately then merge/integrate
```{r vln plots, fig.dim = c(10,8)}
# check how similar the groups are
VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), group.by = "donor")
VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), group.by = "timepoint")
VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), group.by = "treatment")
VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), group.by = "PBMC_or_T")
VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt"), group.by = "sample_id")
```

Do SCTransform on the cluster (takes a few mins) but crashes on normal computer
vars.to.regress removes the effect of mitochondrial gene percentage as a tehcnical covariate from normalised expression values. Thus each gene's expression is adjusted to remove the influence of mitochondrial percentage (as high mt content cells often have biased gene expression profiles)
vst v2 is the default, updated version (as of August 2025)
```{r SCTransform}
scCHANTS_pbmc <- SCTransform(scCHANTS_pbmc, vars.to.regress = "percent_mt", verbose = FALSE, vst.flavor = "v2")
```

```{r check what genes are filtered out}
rna_genes <- rownames(scCHANTS_pbmc[["RNA"]])
length(rna_genes)
sct_genes <- rownames(scCHANTS_pbmc[["SCT"]])
length(sct_genes)

dropped_genes <- setdiff(rna_genes, sct_genes)

# how many genes were filtered out
length(dropped_genes)

# check for a specific gene e.g.
str_detect(dropped_genes, "CLEC4C") %>% 
  sum(na.rm = TRUE)

sum(scCHANTS_pbmc@assays$RNA@counts["CLEC4C", ])
## this is filtered out as only 2 cells express it

str_detect(dropped_genes, "GP9") %>% 
  sum(na.rm = TRUE)

sum(scCHANTS_pbmc@assays$RNA@counts["CLEC4C", ])
## also filtered out as only 2 cells express it

```


```{r Top 10 features}
# identify 10 most highly variable genes
top10_features <- head(VariableFeatures(scCHANTS_pbmc), 10)

# to plot these 10 most variable genes
pca1 <- VariableFeaturePlot(scCHANTS_pbmc) %>% LabelPoints(points = top10_features, repel = TRUE) +
  labs(title = "PBMC Variable features")
pca1
# ggsave("PCA_variablefeatures_labelled.png", plot = pca1, device = png, bg = "white", height = 14, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

## NAs introduced will all befor HTO or ADT rows
hvf_info <- HVFInfo(scCHANTS_pbmc)
summary(is.na(hvf_info))
hvf_info[!complete.cases(hvf_info), ]
```


```{r PCA}
# run PCA
scCHANTS_pbmc <- RunPCA(scCHANTS_pbmc, features = VariableFeatures(object = scCHANTS_pbmc))

DefaultAssay(scCHANTS_pbmc) <- "SCT"
# visualise
pca2 <- VizDimLoadings(scCHANTS_pbmc, dims = 1:2, reduction = "pca")
pca2
# ggsave("PCA_top_pc1to2_genes.png", plot = pca2, device = png, height = 14, width = 18, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )
```


```{r Determine dims}
# to save a heatmap must 'capture it' with png
# while (dev.cur() > 1) dev.off()
# png(paste0(file_path, "/PBMC_plots/PCA/PCA_pc1_heatmap.png"), width = 7, height = 6, units = "in", res = 300 )
DimHeatmap(scCHANTS_pbmc, dims = 1, cells = 500, balanced = TRUE)
#dev.off() # closes png device

# png(paste0(file_path, "/PBMC_plots/PCA/PCA_pc1to15_heatmap.png"), width = 7, height = 16, units = "in", res = 300 )
DimHeatmap(scCHANTS_pbmc, dims = 1:15, cells = 500, balanced = TRUE)
#dev.off() # closes png device

# determine pc number to use
# generate elbow plot and save as a variable
pca3 <- ElbowPlot(scCHANTS_pbmc) +
  labs(title = "PBMC elbow plot")
pca3
# ggsave("PCA_elbowplot.png", plot = pca3, device = png, height = 7, width = 9, unit = "cm", bg = "white", path = paste0(file_path, "/PBMC_plots/PCA/") )

# if not clear then do this calculation to find where drop in variance explained between two successive PCs no longer significant (is <0.1%)
pct <- scCHANTS_pbmc[["pca"]]@stdev / sum(scCHANTS_pbmc[["pca"]]@stdev) * 100
# calculate cumulative percents for each PC
cumu <- cumsum(pct)
# determine the difference between variation of PC and subsequent PC
# give the last point where difference in % of variation is more than 0.1%
sort(which((pct[1:length(pct) - 1] - pct[2:length(pct)]) > 0.1), decreasing = T)[1] + 1
## 11

```

## Deciding resolution for clustering
```{r fig.dim = c(8,8)}
scCHANTS_pbmc <- FindNeighbors(scCHANTS_pbmc, dims = 1:11) 

scCHANTS_pbmc <- FindClusters(scCHANTS_pbmc, resolution = c(0.2, 0.4, 0.5, 0.6, 0.7, 0.8, 1))
# this creates multiple clustering columns named e.g. SCT_snn_res.0.2
colnames(scCHANTS_pbmc@meta.data)
```


```{r  overall tree, fig.dim = c(8,8)}
# sugiyama layout minimises number of crossing edges, can be easier to read
pca4 <- clustree(scCHANTS_pbmc, prefix = "SCT_snn_res.", layout = "sugiyama")
pca4
# ggsave("PCA_compare_res_clusteringtree.png", plot = pca4, device = png, height = 22, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
## decided on 0.7, this is where the branches are relatively stable

# set resolution as default
Idents(scCHANTS_pbmc) <- "SCT_snn_res.0.7"
```

Plot clustree based on gene exp etc
```{r  mean and median tree, fig.dim = c(12,15)}
# use median to see typical expression per cluster, avoid misleading high expressing cells
# mean if interested in total contribution of a gene and know expression isn't skewed
# however, all nodes are same colour across clusters if use median, use mean initially

markers <- c("CD3D", "CD3E", "CD8A", 
             "CD8B", "NKG7", "CD14", 
             "CD79A", "CD1C", "PF4")

gene_trees <- lapply(markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca5 <- wrap_plots(gene_trees, ncol = 3)
pca5
# ggsave("PCA_mean_gene_exp_clusteringtree.png", plot = pca5, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

gene_trees2 <- lapply(markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "median",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca6 <- wrap_plots(gene_trees2, ncol = 3)
pca6
# ggsave("PCA_median_gene_exp_clusteringtree.png", plot = pca6, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r tree for legend, fig.dim = c(8,8)}
# extract and save legend for plasma colour scale
with_legend <- clustree(scCHANTS_pbmc,
                       prefix = "SCT_snn_res.", 
                       node_colour = "CD8B", 
                       layout = "sugiyama", 
                       node_colour_aggr = "mean",
                       node_colour_layer = "data") +
  scale_colour_viridis(option = "plasma")
with_legend

# ggsave("PCA_gene_exp_clusteringtree_legend.png", plot = with_legend, device = png, height = 25, width = 20, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

```

Specific cell type marker genes - using Oelen et al marker genes
```{r  CD4 T cell tree, fig.dim = c(12,15)}
# CD4 T cells
# all high bar last two, CCR7 and SELL in naive, LTB, IL7R AND S100A4 in memory
CD4_markers <- c("CD3D", "CD3E", "CD3G", 
                 "CCR7", "SELL", "LTB", 
                 "IL7R", "CD8A", "CD8B")

CD4_trees <- lapply(CD4_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca7 <- wrap_plots(CD4_trees, ncol = 3)
pca7
# ggsave("PCA_mean_CD4_gene_exp_clusteringtree.png", plot = pca7, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r CD8 T cell tree, fig.dim = c(12,20)}
# CD8 T cells
# all high, CCR7 and SELL in naive, LTB, IL7R AND S100A4 in memory
CD8_markers <- c("CD8A", "CD8B", "CD3D", 
                 "CD3E", "CD3G", "GZMB", 
                 "PRF1", "CCR7", "SELL", 
                 "LTB", "IL7R", "S100A4")

CD8_trees <- lapply(CD8_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca8 <- wrap_plots(CD8_trees, ncol = 3)
pca8
# ggsave("PCA_mean_CD8_gene_exp_clusteringtree.png", plot = pca8, device = png, height = 55, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r monocyte tree, fig.dim = c(12,15)}
# Monocytes
# CD14 high, LYZ, S100A9 and CSF3R high in classical, low in non-classical, FCGR3A, LYN, CSF1R and IFITM1-3 high in non-classical, low in classical
mono_markers <- c("CD14", "LYZ", "S100A9", 
                  "CSF3R", "FCGR3A", "LYN", 
                  "CSF1R", "IFITM1", "IFITM2")

mono_trees <- lapply(mono_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca9 <- wrap_plots(mono_trees, ncol = 3)
pca9
# ggsave("PCA_mean_mono_gene_exp_clusteringtree.png", plot = pca9, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r NK cell tree, fig.dim = c(12,15)}
# NK
# NKG7 nad GNLY high in dim and bright, CD8A/B low, FCGR3A, GZMB and PRF1 high in dim but low in bright, KLRC1 high in bright
NK_markers <- c("NKG7", "GNLY", "FCGR3A", 
                "GZMB", "PRF1", "KLRC1", 
                "CD8A", "CD8B")

NK_trees <- lapply(NK_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca10 <- wrap_plots(NK_trees, ncol = 3)
pca10
# ggsave("PCA_mean_NK_gene_exp_clusteringtree.png", plot = pca10, device = png, height = 40, width = 45, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r B cell tree, fig.dim = c(8,8)}
# B
# all high, no MS4A1 in plasma
B_markers <- c("CD79A", "MS4A1")

B_trees <- lapply(B_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca11 <- wrap_plots(B_trees, ncol = 2)
pca11
# ggsave("PCA_mean_B_gene_exp_clusteringtree.png", plot = pca11, device = png, height = 14, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r DC tree, fig.dim = c(12,10)}
# DC
# CD1C and ITGAX high in myeloid, CLEC4C low, CLEC4C high in plasmacytoid, CD1C, ITGAX low, CD14 low in both
DC_markers <- c("CD1C", "ITGAX", 
                "CD14")
                #"CLEC4C", "CD14") # CLEC4C was removed by SCTransform as it is only expressed in 2 cells (minimum is 5)

DC_trees <- lapply(DC_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca12 <- wrap_plots(DC_trees, ncol = 2)
pca12
# ggsave("PCA_mean_DC_gene_exp_clusteringtree.png", plot = pca12, device = png, height = 30, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )
```


```{r megakaryocyte tree, fig.dim = c(12,10)}
# megakaryotcytes
# all high
megak_markers <- c("ITGA2B",
                   #"GP9", "ITGA2B", # GP9 was removed
                   "PF4", "PPBP")

megak_trees <- lapply(megak_markers, function(gene) {
  clustree(scCHANTS_pbmc,
           prefix = "SCT_snn_res.",
           layout = "sugiyama",
           node_colour = gene,
           node_colour_aggr = "mean",
           node_colour_layer = "data") + 
    ggtitle(gene) +
    theme(legend.position = "none") +
    scale_colour_viridis(option = "plasma")
}) 
  
pca13 <- wrap_plots(megak_trees, ncol = 2)
pca13
# ggsave("PCA_mean_megak_gene_exp_clusteringtree.png", plot = pca13, device = png, height = 30, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/clustree") )

```



## Run umap and visualise
```{r fig.dim = c(9,15)}
scCHANTS_pbmc <- RunUMAP(scCHANTS_pbmc, dims = 1:11)

# create an empty list to hold the plots
umap_plots <- list()

# loop through each resolution
for (res in c("0.2", "0.4", "0.5", "0.6", "0.7", "0.8", "1")) {
  res_col <- paste0("SCT_snn_res.", res)
  Idents(scCHANTS_pbmc) <- res_col
  
  p <- DimPlot(scCHANTS_pbmc, reduction = "umap", label = TRUE) +
       ggtitle(paste("Resolution", res))
  
  umap_plots[[as.character(res)]] <- p
}

#combine plots into a grid layout
pca14 <- wrap_plots(umap_plots, ncol = 3)
pca14
# ggsave("PCA_compare_res_umaps.png", plot = pca14, device = png, height = 25, width =30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )
```


```{r fig.dim = c(12,10)}
# plot RNA counts, mt and rb contamination
pca15 <- VlnPlot(scCHANTS_pbmc, features = c("nFeature_RNA", "nCount_RNA", "percent_mt", "percent_rb"), ncol = 2, alpha = 0.3, group.by = "SCT_snn_res.0.7")
pca15
# ggsave("PCA_compare_clusters_violinplots.png", plot = pca15, device = png, height = 22, width = 30, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )
```


```{r}
# plot cluster sizes, must extract first
cluster_counts <- table(Idents(scCHANTS_pbmc)) %>% 
  as.data.frame() %>% 
  mutate(Var1 = as.factor(Var1)) # so can colour based on it
colnames(cluster_counts) <- c("cluster", "cell_count")

head(cluster_counts)

pca16 <- ggplot(cluster_counts, aes(x = cluster, y = cell_count, fill = cluster)) +
  geom_bar(stat = "identity") +
  theme_minimal() +
  labs(title = "Cluster Sizes", x = "Cluster", y = "Number of Cells") +
  theme(legend.position = "none")
pca16
# ggsave("PCA_compare_cluster_size_barplots.png", plot = pca16, device = png, height = 10, width = 10, unit = "cm", bg = "white", path = paste0(file_path, "/PBMC_plots/PCA/") )
```



## Remove clustering resolution columns
```{r}
scCHANTS_pbmc@meta.data <- scCHANTS_pbmc@meta.data[, !grepl("SCT_snn_res", colnames(scCHANTS_pbmc@meta.data))]

# recluster with determined resolution
scCHANTS_pbmc <- FindClusters(scCHANTS_pbmc, resolution = 0.7)

colnames(scCHANTS_pbmc@meta.data)
Idents(scCHANTS_pbmc) <- "SCT_snn_res.0.7"

```



```{r}
# plot umap coloured by cell_type and cell_type_lowerres
pca17 <- DimPlot(scCHANTS_pbmc, reduction = "umap", split.by = "timepoint", group.by = "donor", ncol = 2, alpha = 0.7) +
  ggtitle("By timepoint")
pca17
# ggsave("PCA_by_timepoint_umap.png", plot = pca17, device = png, height = 10, width =10, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

pca18 <- DimPlot(scCHANTS_pbmc, reduction = "umap", split.by = "donor", group.by = "timepoint", ncol = 2, alpha = 0.7) +
  ggtitle("By donor")
pca18
# ggsave("PCA_by_donor_umap.png", plot = pca18, device = png, height = 10, width =13, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

scCHANTS_pbmc_bm <- subset(scCHANTS_pbmc, subset = timepoint == "benchmark")
pca19 <- DimPlot(scCHANTS_pbmc_bm, reduction = "umap", split.by = "donor", group.by = "SCT_snn_res.0.7", ncol = 2) +
  ggtitle("Benchmark by donor")
pca19
# ggsave("PCA_benchmark_by_donor_umap.png", plot = pca19, device = png, height = 10, width =13, unit = "cm", path = paste0(file_path, "/PBMC_plots/PCA/") )

```

Remove PCA plots
```{r}
rm(hvf_info, p, with_legend, pca1, pca2, pca3, pca4, pca5, pca6, pca7, pca8, pca9, pca10, pca11, pca12, pca13, pca14, pca15, pca16, pca17, pca18, pca19, B_trees, CD4_trees, CD8_trees, DC_trees, gene_trees, gene_trees2, megak_trees, mono_trees, NK_trees, umap_plots, cluster_counts)
```


## Find markers for clusters
I recommend running find markers and saveRDS as a batch script, see ~/R/scCHANTS/script_2.2_process_save_20250805_pbmc.R
```{r}
# recommended to do on RNA assay for differential expression, not SCT, normalise as default
scCHANTS_pbmc <- NormalizeData(scCHANTS_pbmc, assay = "RNA", normalization.method = "LogNormalize")
DefaultAssay(scCHANTS_pbmc) <- "RNA"

# find markers for every cluster compared to all remaining cells, report only the positive ones
pbmc_markers <- FindAllMarkers(scCHANTS_pbmc, only.pos = TRUE)

# write.csv(pbmc_markers,"/scratch/prj/id_hill_sims_wellcda/scCHANTS/20250805_run1/20250805_scCHANTS_pbmc_markers.csv")

pbmc_markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>% 
  head(n = 30)
```

## save PBMC pre-processed RDS (takes a long time)
Save before joining layers to find markers
I recommend running find markers and saveRDS as a batch script, see ~/R/scCHANTS/script_2.2_process_save_20250805_pbmc.R
```{r}
#saveRDS(object = scCHANTS_pbmc, file ="/scratch/prj/id_hill_sims_wellcda/scCHANTS/20250805_run1/20250805_scCHANTS_pbmc_processed.Rds")

```